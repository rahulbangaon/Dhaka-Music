{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/entry/router.ts"],"sourcesContent":["import type { Ipc, StructuredError } from '@vercel/turbopack-node/ipc/index'\nimport type { IncomingMessage } from 'node:http'\nimport { Buffer } from 'node:buffer'\nimport { createServer, makeRequest, type ServerInfo } from '../internal/server'\nimport { toPairs } from '../internal/headers'\nimport { makeResolver } from 'next/dist/server/lib/route-resolver'\nimport loadConfig from 'next/dist/server/config'\nimport { PHASE_DEVELOPMENT_SERVER } from 'next/dist/shared/lib/constants'\n\nimport 'next/dist/server/node-polyfill-fetch.js'\n\nimport middlewareChunkGroup from 'MIDDLEWARE_CHUNK_GROUP'\nimport middlewareConfig from 'MIDDLEWARE_CONFIG'\n\ntype Resolver = Awaited<\n  ReturnType<typeof import('next/dist/server/lib/route-resolver').makeResolver>\n>\n\ntype RouterRequest = {\n  method: string\n  pathname: string\n  rawHeaders: [string, string][]\n  rawQuery: string\n  body: number[][]\n}\n\ntype IpcOutgoingMessage = {\n  type: 'value'\n  data: string | Buffer\n}\n\ntype MessageData =\n  | { type: 'middleware-headers'; data: MiddlewareHeadersResponse }\n  | { type: 'middleware-body'; data: Uint8Array }\n  | {\n      type: 'rewrite'\n      data: RewriteResponse\n    }\n  | {\n      type: 'error'\n      error: StructuredError\n    }\n  | { type: 'none' }\n\ntype RewriteResponse = {\n  url: string\n  headers: [string, string][]\n}\n\ntype MiddlewareHeadersResponse = {\n  statusCode: number\n  headers: [string, string][]\n}\n\nlet resolveRouteMemo: Promise<Resolver>\n\nasync function getResolveRoute(\n  dir: string,\n  serverInfo: ServerInfo\n): Promise<Resolver> {\n  const nextConfig = await loadConfig(\n    PHASE_DEVELOPMENT_SERVER,\n    process.cwd(),\n    undefined,\n    undefined,\n    true\n  )\n  const middlewareCfg = {\n    files: middlewareChunkGroup.filter((f) => /\\.[mc]?js$/.test(f)),\n    matcher: middlewareConfig.matcher,\n  }\n\n  return await makeResolver(dir, nextConfig, middlewareCfg, serverInfo)\n}\n\nexport default async function route(\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\n  routerRequest: RouterRequest,\n  dir: string,\n  serverInfo: ServerInfo\n) {\n  const [resolveRoute, server] = await Promise.all([\n    (resolveRouteMemo ??= getResolveRoute(dir, serverInfo)),\n    createServer(),\n  ])\n\n  try {\n    const {\n      clientRequest,\n      clientResponsePromise,\n      serverRequest,\n      serverResponse,\n    } = await makeRequest(\n      server,\n      routerRequest.method,\n      routerRequest.pathname,\n      routerRequest.rawQuery,\n      routerRequest.rawHeaders,\n      serverInfo\n    )\n\n    const body = Buffer.concat(\n      routerRequest.body.map((arr) => Buffer.from(arr))\n    )\n\n    // Send the clientRequest, so the server parses everything. We can then pass\n    // the serverRequest to Next.js to handle.\n    clientRequest.end(body)\n\n    // The route promise must not block us from starting the middleware\n    // response handling, so we cannot await it yet. By making the call, we\n    // allow Next.js to start writing to the response whenever it's ready.\n    const routePromise = resolveRoute(serverRequest, serverResponse)\n\n    // Now that the Next.js has started processing the route, the middleware\n    // response promise will resolve once they write data and then we can begin\n    // streaming.\n    // We again cannot await directly on the promise, because an error may\n    // occur in the routePromise while we're waiting.\n    const middlewarePromise = clientResponsePromise.then((c) =>\n      handleMiddlewareResponse(ipc, c)\n    )\n\n    // Now that both promises are in progress, we await both so that a\n    // rejection in either will end the routing.\n    const [routeResult] = await Promise.all([routePromise, middlewarePromise])\n\n    server.close()\n\n    if (routeResult) {\n      switch (routeResult.type) {\n        case 'none':\n        case 'error':\n          return routeResult\n        case 'rewrite':\n          return {\n            type: 'rewrite',\n            data: {\n              url: routeResult.url,\n              headers: Object.entries(routeResult.headers)\n                .filter(([, val]) => val != null)\n                .map(([name, value]) => [name, value!.toString()]),\n            },\n          }\n        default:\n          // @ts-expect-error data.type is never\n          throw new Error(`unknown route result type: ${data.type}`)\n      }\n    }\n  } catch (e) {\n    // Server doesn't need to be closed, because the sendError will terminate\n    // the process.\n    ipc.sendError(e as Error)\n  }\n}\n\nasync function handleMiddlewareResponse(\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\n  clientResponse: IncomingMessage\n): Promise<void> {\n  // If this header is specified, we know that the response was not handled by\n  // middleware. The headers and body of the response are useless.\n  if (clientResponse.headers['x-nextjs-route-result']) {\n    return\n  }\n\n  const responseHeaders: MiddlewareHeadersResponse = {\n    statusCode: clientResponse.statusCode!,\n    headers: toPairs(clientResponse.rawHeaders),\n  }\n\n  await ipc.send({\n    type: 'value',\n    data: JSON.stringify({\n      type: 'middleware-headers',\n      data: responseHeaders,\n    }),\n  })\n\n  for await (const chunk of clientResponse) {\n    await ipc.send({\n      type: 'value',\n      data: JSON.stringify({\n        type: 'middleware-body',\n        data: (chunk as Buffer).toJSON().data,\n      }),\n    })\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsDA,IAAI;AAEJ,eAAe,gBACb,GAAW,EACX,UAAsB;IAEtB,MAAM,aAAa,MAAM,sKAEvB,QAAQ,OACR,WACA,WACA;IAEF,MAAM,gBAAgB;QACpB,OAAO,kGAAqB,OAAO,CAAC,IAAM,aAAa,KAAK;QAC5D,SAAS,yGAAiB;IAC5B;IAEA,OAAO,MAAM,4FAAa,KAAK,YAAY,eAAe;AAC5D;AAEe,eAAe,MAC5B,GAA2C,EAC3C,aAA4B,EAC5B,GAAW,EACX,UAAsB;IAEtB,MAAM,CAAC,cAAc,OAAO,GAAG,MAAM,QAAQ,IAAI;QAC9C,qBAAqB,gBAAgB,KAAK;QAC3C;KACD;IAED,IAAI;QACF,MAAM,EACJ,aAAa,EACb,qBAAqB,EACrB,aAAa,EACb,cAAc,EACf,GAAG,MAAM,2GACR,QACA,cAAc,QACd,cAAc,UACd,cAAc,UACd,cAAc,YACd;QAGF,MAAM,OAAO,kDAAO,OAClB,cAAc,KAAK,IAAI,CAAC,MAAQ,kDAAO,KAAK;QAK9C,cAAc,IAAI;QAKlB,MAAM,eAAe,aAAa,eAAe;QAOjD,MAAM,oBAAoB,sBAAsB,KAAK,CAAC,IACpD,yBAAyB,KAAK;QAKhC,MAAM,CAAC,YAAY,GAAG,MAAM,QAAQ,IAAI;YAAC;YAAc;SAAkB;QAEzE,OAAO;QAEP,IAAI,aAAa;YACf,OAAQ,YAAY;gBAClB,KAAK;gBACL,KAAK;oBACH,OAAO;gBACT,KAAK;oBACH,OAAO;wBACL,MAAM;wBACN,MAAM;4BACJ,KAAK,YAAY;4BACjB,SAAS,OAAO,QAAQ,YAAY,SACjC,OAAO,CAAC,GAAG,IAAI,GAAK,OAAO,MAC3B,IAAI,CAAC,CAAC,MAAM,MAAM,GAAK;oCAAC;oCAAM,MAAO;iCAAW;wBACrD;oBACF;gBACF;oBAEE,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,KAAK,KAAK,CAAC;YAC7D;QACF;IACF,EAAE,OAAO,GAAG;QAGV,IAAI,UAAU;IAChB;AACF;AAEA,eAAe,yBACb,GAA2C,EAC3C,cAA+B;IAI/B,IAAI,eAAe,OAAO,CAAC,wBAAwB,EAAE;QACnD;IACF;IAEA,MAAM,kBAA6C;QACjD,YAAY,eAAe;QAC3B,SAAS,wGAAQ,eAAe;IAClC;IAEA,MAAM,IAAI,KAAK;QACb,MAAM;QACN,MAAM,KAAK,UAAU;YACnB,MAAM;YACN,MAAM;QACR;IACF;IAEA,WAAW,MAAM,SAAS,eAAgB;QACxC,MAAM,IAAI,KAAK;YACb,MAAM;YACN,MAAM,KAAK,UAAU;gBACnB,MAAM;gBACN,MAAM,AAAC,MAAiB,SAAS;YACnC;QACF;IACF;AACF"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}