{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/headers.ts"],"sourcesContent":["import { ServerInfo } from './server'\n\nexport type Headers = Record<string, string | string[]>\n/**\n * Converts an array of raw header entries to a map of header names to values.\n */\nexport function headersFromEntries(entries: Array<[string, string]>): Headers {\n  const headers: Record<string, string | string[]> = Object.create(null)\n  for (const [key, value] of entries) {\n    if (key in headers) {\n      const prevValue = headers[key]\n      if (typeof prevValue === 'string') {\n        headers[key] = [prevValue, value]\n      } else {\n        prevValue.push(value)\n      }\n    } else {\n      headers[key] = value\n    }\n  }\n  return headers\n}\n\n/**\n * Transforms an array of elements into an array of pairs of elements.\n *\n * ## Example\n *\n * ```ts\n * toPairs([\"a\", \"b\", \"c\", \"d\"]) // => [[\"a\", \"b\"], [\"c\", \"d\"]]\n * ```\n */\nexport function toPairs<T>(arr: T[]): Array<[T, T]> {\n  if (arr.length % 2 !== 0) {\n    throw new Error('toPairs: expected an even number of elements')\n  }\n\n  const pairs: Array<[T, T]> = []\n  for (let i = 0; i < arr.length; i += 2) {\n    pairs.push([arr[i], arr[i + 1]])\n  }\n\n  return pairs\n}\n\n/**\n * These headers are provided by default to match the http-proxy behavior\n * https://github.com/http-party/node-http-proxy/blob/9b96cd72/lib/http-proxy/passes/web-incoming.js#L58-L86\n */\nexport function initProxiedHeaders(\n  headers: Headers,\n  proxiedFor: ServerInfo | null | undefined\n): Headers {\n  const hostname = proxiedFor?.hostname || 'localhost'\n  const port = String(proxiedFor?.port || 3000)\n  headers['x-forwarded-for'] = proxiedFor?.ip || '::1'\n  headers['x-forwarded-host'] = `${hostname}:${port}`\n  headers['x-forwarded-port'] = port\n  headers['x-forwarded-proto'] = proxiedFor?.protocol || 'http'\n  return headers\n}\n"],"names":[],"mappings":";;;;;AAMO,SAAS,mBAAmB,OAAgC;IACjE,MAAM,UAA6C,OAAO,OAAO;IACjE,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,QAAS;QAClC,IAAI,OAAO,SAAS;YAClB,MAAM,YAAY,OAAO,CAAC,IAAI;YAC9B,IAAI,OAAO,cAAc,UAAU;gBACjC,OAAO,CAAC,IAAI,GAAG;oBAAC;oBAAW;iBAAM;YACnC,OAAO;gBACL,UAAU,KAAK;YACjB;QACF,OAAO;YACL,OAAO,CAAC,IAAI,GAAG;QACjB;IACF;IACA,OAAO;AACT;AAWO,SAAS,QAAW,GAAQ;IACjC,IAAI,IAAI,SAAS,MAAM,GAAG;QACxB,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,QAAuB,EAAE;IAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,EAAG;QACtC,MAAM,KAAK;YAAC,GAAG,CAAC,EAAE;YAAE,GAAG,CAAC,IAAI,EAAE;SAAC;IACjC;IAEA,OAAO;AACT;AAMO,SAAS,mBACd,OAAgB,EAChB,UAAyC;IAEzC,MAAM,WAAW,YAAY,YAAY;IACzC,MAAM,OAAO,OAAO,YAAY,QAAQ;IACxC,OAAO,CAAC,kBAAkB,GAAG,YAAY,MAAM;IAC/C,OAAO,CAAC,mBAAmB,GAAG,CAAC,EAAE,SAAS,CAAC,EAAE,KAAK,CAAC;IACnD,OAAO,CAAC,mBAAmB,GAAG;IAC9B,OAAO,CAAC,oBAAoB,GAAG,YAAY,YAAY;IACvD,OAAO;AACT"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/server.ts"],"sourcesContent":["import type { ClientRequest, IncomingMessage, Server } from 'node:http'\nimport type { AddressInfo } from 'node:net'\nimport http, { ServerResponse } from 'node:http'\nimport { headersFromEntries, initProxiedHeaders } from './headers'\n\nexport type ServerInfo = Partial<{\n  hostname: string\n  port: number\n  ip: string\n  protocol: string\n}>\n\n/**\n * Creates a server that listens a random port.\n */\nexport function createServer(): Promise<Server> {\n  return new Promise((resolve) => {\n    const server = http.createServer()\n    server.listen(0, () => {\n      resolve(server)\n    })\n  })\n}\n\n/**\n * Creates a request to a server, and returns the (req, res) pairs from both\n * the client's and server's perspective.\n */\nexport function makeRequest(\n  server: Server,\n  method: string,\n  path: string,\n  rawQuery?: string,\n  rawHeaders?: [string, string][],\n  proxiedFor?: ServerInfo\n): Promise<{\n  clientRequest: ClientRequest\n  clientResponsePromise: Promise<IncomingMessage>\n  serverRequest: IncomingMessage\n  serverResponse: ServerResponse<IncomingMessage>\n}> {\n  return new Promise((resolve, reject) => {\n    let clientResponseResolve: (value: IncomingMessage) => void\n    let clientResponseReject: (error: Error) => void\n    const clientResponsePromise = new Promise<IncomingMessage>(\n      (resolve, reject) => {\n        clientResponseResolve = resolve\n        clientResponseReject = reject\n      }\n    )\n\n    const errorListener = (err: Error) => {\n      server.removeListener('request', requestListener)\n      reject(err)\n    }\n\n    const requestListener = (\n      req: IncomingMessage,\n      res: ServerResponse<IncomingMessage>\n    ) => {\n      server.removeListener('error', errorListener)\n      resolve({\n        clientRequest,\n        clientResponsePromise,\n        serverRequest: req,\n        serverResponse: res,\n      })\n    }\n\n    server.once('request', requestListener)\n    server.once('error', errorListener)\n\n    const address = server.address() as AddressInfo\n\n    const headers = headersFromEntries(rawHeaders ?? [])\n    initProxiedHeaders(headers, proxiedFor)\n\n    const clientRequest = http.request({\n      host: 'localhost',\n      port: address.port,\n      method,\n      path: rawQuery?.length ? `${path}?${rawQuery}` : path,\n      headers,\n    })\n\n    // Otherwise Node.js waits for the first chunk of data to be written before sending the request.\n    clientRequest.flushHeaders()\n\n    const clientResponseErrorListener = (err: Error) => {\n      clientRequest.removeListener('response', responseListener)\n      clientResponseReject(err)\n    }\n\n    const responseListener = (res: IncomingMessage) => {\n      clientRequest.removeListener('error', clientResponseErrorListener)\n      clientResponseResolve(res)\n    }\n\n    clientRequest.once('response', responseListener)\n    clientRequest.once('error', clientResponseErrorListener)\n  })\n}\n"],"names":[],"mappings":";;;;;;;;;AAeO,SAAS;IACd,OAAO,IAAI,QAAQ,CAAC;QAClB,MAAM,SAAS,iDAAK;QACpB,OAAO,OAAO,GAAG;YACf,QAAQ;QACV;IACF;AACF;AAMO,SAAS,YACd,MAAc,EACd,MAAc,EACd,IAAY,EACZ,QAAiB,EACjB,UAA+B,EAC/B,UAAuB;IAOvB,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,IAAI;QACJ,IAAI;QACJ,MAAM,wBAAwB,IAAI,QAChC,CAAC,SAAS;YACR,wBAAwB;YACxB,uBAAuB;QACzB;QAGF,MAAM,gBAAgB,CAAC;YACrB,OAAO,eAAe,WAAW;YACjC,OAAO;QACT;QAEA,MAAM,kBAAkB,CACtB,KACA;YAEA,OAAO,eAAe,SAAS;YAC/B,QAAQ;gBACN;gBACA;gBACA,eAAe;gBACf,gBAAgB;YAClB;QACF;QAEA,OAAO,KAAK,WAAW;QACvB,OAAO,KAAK,SAAS;QAErB,MAAM,UAAU,OAAO;QAEvB,MAAM,UAAU,mHAAmB,cAAc,EAAE;QACnD,mHAAmB,SAAS;QAE5B,MAAM,gBAAgB,iDAAK,QAAQ;YACjC,MAAM;YACN,MAAM,QAAQ;YACd;YACA,MAAM,UAAU,SAAS,CAAC,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC,GAAG;YACjD;QACF;QAGA,cAAc;QAEd,MAAM,8BAA8B,CAAC;YACnC,cAAc,eAAe,YAAY;YACzC,qBAAqB;QACvB;QAEA,MAAM,mBAAmB,CAAC;YACxB,cAAc,eAAe,SAAS;YACtC,sBAAsB;QACxB;QAEA,cAAc,KAAK,YAAY;QAC/B,cAAc,KAAK,SAAS;IAC9B;AACF"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}